//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.16613
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.ApplicationServer.Serialization {
    
    
    internal partial class SR {
        
        static System.Resources.ResourceManager resourceManager;
        
        static System.Globalization.CultureInfo resourceCulture;
        
        private SR() {
        }
        
        internal static System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceManager, null)) {
                    System.Resources.ResourceManager temp = new System.Resources.ResourceManager("Microsoft.ApplicationServer.Serialization.SR", typeof(SR).Assembly);
                    resourceManager = temp;
                }
                return resourceManager;
            }
        }
        
        [System.CodeDom.Compiler.GeneratedCodeAttribute("StrictResXFileCodeGenerator", "4.0.0.0")]
        internal static System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>Gets localized string like: Multi-dimensional arrays are not supported.</summary>
        internal static string SupportForMultidimensionalArraysNotPresent {
            get {
                return ResourceManager.GetString("SupportForMultidimensionalArraysNotPresent", Culture);
            }
        }
        
        /// <summary>Gets localized string like: DataContractSerializer config section under System.Runtime.Serialization section group could not be loaded. Verify that machine.config is correctly set up.</summary>
        internal static string ConfigDataContractSerializerSectionLoadError  {
            get {
                return ResourceManager.GetString("ConfigDataContractSerializerSectionLoadError ", Culture);
            }
        }
        
        /// <summary>Gets localized string like: An internal error has occurred. DataContract cache overflow.</summary>
        internal static string DataContractCacheOverflow {
            get {
                return ResourceManager.GetString("DataContractCacheOverflow", Culture);
            }
        }
        
        /// <summary>Gets localized string like: Only classes can be generated as ISerializable.</summary>
        internal static string RequiresClassDataContractToSetIsISerializable {
            get {
                return ResourceManager.GetString("RequiresClassDataContractToSetIsISerializable", Culture);
            }
        }
        
        /// <summary>Gets localized string like: ReferencedCollectionTypes specified via ImportOptions must contain valid types. Cannot contain null.</summary>
        internal static string ReferencedCollectionTypesCannotContainNull {
            get {
                return ResourceManager.GetString("ReferencedCollectionTypesCannotContainNull", Culture);
            }
        }
        
        /// <summary>Gets localized string like: (matching)</summary>
        internal static string ReferencedTypeMatchingMessage {
            get {
                return ResourceManager.GetString("ReferencedTypeMatchingMessage", Culture);
            }
        }
        
        /// <summary>Gets localized string like: (not matching)</summary>
        internal static string ReferencedTypeNotMatchingMessage {
            get {
                return ResourceManager.GetString("ReferencedTypeNotMatchingMessage", Culture);
            }
        }
        
        /// <summary>Gets localized string like: ReferencedTypes specified via ImportOptions must contain valid types. Cannot contain null.</summary>
        internal static string ReferencedTypesCannotContainNull {
            get {
                return ResourceManager.GetString("ReferencedTypesCannotContainNull", Culture);
            }
        }
        
        /// <summary>Gets localized string like: Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</param>
        /// <param name="param1">Parameter 1 for string: Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</param>
        /// <param name="param2">Parameter 2 for string: Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</param>
        /// <param name="param3">Parameter 3 for string: Type '{2}' contains two members '{0}' 'and '{1}' with the same name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using EnumMemberAttribute attribute.</param>
        internal static string DupEnumMemberValue(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("DupEnumMemberValue", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</param>
        /// <param name="param1">Parameter 1 for string: Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</param>
        /// <param name="param2">Parameter 2 for string: Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</param>
        /// <param name="param3">Parameter 3 for string: Type '{2}' contains two members '{0}' 'and '{1}' with the same data member name '{3}'. Multiple members with the same name in one type are not supported. Consider changing one of the member names using DataMemberAttribute attribute.</param>
        internal static string DupMemberName(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("DupMemberName", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot be ISerializable and have DataContractAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot be ISerializable and have DataContractAttribute attribute.</param>
        internal static string ISerializableCannotHaveDataContract(object param0) {
            return string.Format(Culture, ResourceManager.GetString("ISerializableCannotHaveDataContract", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</param>
        /// <param name="param1">Parameter 1 for string: Type '{0}' cannot inherit from a type that is not marked with DataContractAttribute or SerializableAttribute.  Consider marking the base type '{1}' with DataContractAttribute or SerializableAttribute, or removing them from the derived type.</param>
        internal static string AttributedTypesCannotInheritFromNonAttributedSerializableTypes(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("AttributedTypesCannotInheritFromNonAttributedSerializableTypes", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Type '{0}' does not have DataContractAttribute attribute and therefore cannot support IExtensibleDataObject. </summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' does not have DataContractAttribute attribute and therefore cannot support IExtensibleDataObject. </param>
        internal static string OnlyDataContractTypesCanHaveExtensionData(object param0) {
            return string.Format(Culture, ResourceManager.GetString("OnlyDataContractTypesCanHaveExtensionData", Culture), param0);
        }
        
        /// <summary>Gets localized string like: The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</summary>
        /// <param name="param0">Parameter 0 for string: The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</param>
        /// <param name="param1">Parameter 1 for string: The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</param>
        /// <param name="param2">Parameter 2 for string: The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</param>
        /// <param name="param3">Parameter 3 for string: The IsReference setting for type '{0}' is '{1}', but the same setting for its parent class '{2}' is '{3}'. Derived types must have the same value for IsReference as the base type. Change the setting on type '{0}' to '{3}', or on type '{2}' to '{1}', or do not set IsReference explicitly.</param>
        internal static string InconsistentIsReference(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("InconsistentIsReference", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</summary>
        /// <param name="param0">Parameter 0 for string: Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</param>
        /// <param name="param1">Parameter 1 for string: Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</param>
        /// <param name="param2">Parameter 2 for string: Value type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</param>
        internal static string ValueTypeCannotHaveIsReference(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("ValueTypeCannotHaveIsReference", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: Member '{0}.{1}' has more than one DataMemberAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Member '{0}.{1}' has more than one DataMemberAttribute attribute.</param>
        /// <param name="param1">Parameter 1 for string: Member '{0}.{1}' has more than one DataMemberAttribute attribute.</param>
        internal static string TooManyDataMembers(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("TooManyDataMembers", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: No get method for property '{1}' in type '{0}'.</summary>
        /// <param name="param0">Parameter 0 for string: No get method for property '{1}' in type '{0}'.</param>
        /// <param name="param1">Parameter 1 for string: No get method for property '{1}' in type '{0}'.</param>
        internal static string NoGetMethodForProperty(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("NoGetMethodForProperty", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: No set method for property '{1}' in type '{0}'.</summary>
        /// <param name="param0">Parameter 0 for string: No set method for property '{1}' in type '{0}'.</param>
        /// <param name="param1">Parameter 1 for string: No set method for property '{1}' in type '{0}'.</param>
        internal static string NoSetMethodForProperty(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("NoSetMethodForProperty", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</summary>
        /// <param name="param0">Parameter 0 for string: Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</param>
        /// <param name="param1">Parameter 1 for string: Property '{1}' in type '{0}' cannot be serialized because serialization of indexed properties is not supported.</param>
        internal static string IndexedPropertyCannotBeSerialized(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("IndexedPropertyCannotBeSerialized", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</summary>
        /// <param name="param0">Parameter 0 for string: Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</param>
        /// <param name="param1">Parameter 1 for string: Member '{0}.{1}' cannot be serialized since it is neither a field nor a property, and therefore cannot be marked with the DataMemberAttribute attribute. Remove the DataMemberAttribute attribute from the '{1}' member.</param>
        internal static string InvalidMember(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("InvalidMember", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: '{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </summary>
        /// <param name="param0">Parameter 0 for string: '{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </param>
        /// <param name="param1">Parameter 1 for string: '{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </param>
        /// <param name="param2">Parameter 2 for string: '{0}.{1}' has the IsRequired setting of '{2}. However, '{0}' has the IsReference setting of '{2}', because either it is set explicitly, or it is derived from a base class. Set IsRequired on '{0}.{1}' to false, or disable IsReference on '{0}'. </param>
        internal static string IsRequiredDataMemberOnIsReferenceDataContractType(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("IsRequiredDataMemberOnIsReferenceDataContractType", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</param>
        /// <param name="param1">Parameter 1 for string: Member '{0}.{1}' has more than one IgnoreDataMemberAttribute attribute.</param>
        internal static string TooManyIgnoreDataMemberAttributes(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("TooManyIgnoreDataMemberAttributes", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: '{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</summary>
        /// <param name="param0">Parameter 0 for string: '{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</param>
        /// <param name="param1">Parameter 1 for string: '{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</param>
        /// <param name="param2">Parameter 2 for string: '{0}.{1}' is not marked with OptionalFieldAttribute, thus indicating that it must be serialized. However, '{0}' derives from a class marked with DataContractAttribute and an IsReference setting of '{2}'. It is not possible to have required data members on IsReference classes. Either decorate '{0}.{1}' with OptionalFieldAttribute, or disable the IsReference setting on the appropriate parent class.</param>
        internal static string NonOptionalFieldMemberOnIsReferenceSerializableType(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("NonOptionalFieldMemberOnIsReferenceSerializableType", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: Invalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.</summary>
        /// <param name="param0">Parameter 0 for string: Invalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.</param>
        /// <param name="param1">Parameter 1 for string: Invalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.</param>
        /// <param name="param2">Parameter 2 for string: Invalid IExtensibleDataObject. Both '{0}' and '{1}' in type '{2}' provide property setter.</param>
        internal static string DuplicateExtensionDataSetMethod(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("DuplicateExtensionDataSetMethod", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: IExtensibleDataObject property setter '{1}' in type '{0}' must return void.</summary>
        /// <param name="param0">Parameter 0 for string: IExtensibleDataObject property setter '{1}' in type '{0}' must return void.</param>
        /// <param name="param1">Parameter 1 for string: IExtensibleDataObject property setter '{1}' in type '{0}' must return void.</param>
        internal static string ExtensionDataSetMustReturnVoid(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("ExtensionDataSetMustReturnVoid", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: IExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.</summary>
        /// <param name="param0">Parameter 0 for string: IExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.</param>
        /// <param name="param1">Parameter 1 for string: IExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.</param>
        /// <param name="param2">Parameter 2 for string: IExtensibleDataObject property setter '{1}' in type '{0}' must have a single parameter of type '{2}'.</param>
        internal static string ExtensionDataSetParameterInvalid(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("ExtensionDataSetParameterInvalid", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</summary>
        /// <param name="param0">Parameter 0 for string: Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</param>
        /// <param name="param1">Parameter 1 for string: Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</param>
        /// <param name="param2">Parameter 2 for string: Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</param>
        /// <param name="param3">Parameter 3 for string: Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.</param>
        internal static string DuplicateCallback(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("DuplicateCallback", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</summary>
        /// <param name="param0">Parameter 0 for string: Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</param>
        /// <param name="param1">Parameter 1 for string: Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</param>
        /// <param name="param2">Parameter 2 for string: Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</param>
        /// <param name="param3">Parameter 3 for string: Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.</param>
        internal static string DuplicateAttribute(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("DuplicateAttribute", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</param>
        /// <param name="param1">Parameter 1 for string: Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</param>
        /// <param name="param2">Parameter 2 for string: Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.</param>
        internal static string CallbacksCannotBeVirtualMethods(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("CallbacksCannotBeVirtualMethods", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: Serialization Callback '{1}' in type '{0}' must return void.</summary>
        /// <param name="param0">Parameter 0 for string: Serialization Callback '{1}' in type '{0}' must return void.</param>
        /// <param name="param1">Parameter 1 for string: Serialization Callback '{1}' in type '{0}' must return void.</param>
        internal static string CallbackMustReturnVoid(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("CallbackMustReturnVoid", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</summary>
        /// <param name="param0">Parameter 0 for string: Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</param>
        /// <param name="param1">Parameter 1 for string: Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</param>
        /// <param name="param2">Parameter 2 for string: Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.</param>
        internal static string CallbackParameterInvalid(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("CallbackParameterInvalid", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</summary>
        /// <param name="param0">Parameter 0 for string: Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</param>
        /// <param name="param1">Parameter 1 for string: Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</param>
        /// <param name="param2">Parameter 2 for string: Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</param>
        /// <param name="param3">Parameter 3 for string: Data contract '{0}' from namespace '{1}' is a value type and cannot have base contract '{2}' from namespace '{3}'.</param>
        internal static string ValueTypeCannotHaveBaseType(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("ValueTypeCannotHaveBaseType", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: {0} The class cannot be deserialized.</summary>
        /// <param name="param0">Parameter 0 for string: {0} The class cannot be deserialized.</param>
        internal static string ReadOnlyClassDeserialization(object param0) {
            return string.Format(Culture, ResourceManager.GetString("ReadOnlyClassDeserialization", Culture), param0);
        }
        
        /// <summary>Gets localized string like: The Type '{0}' must have a parameterless constructor.</summary>
        /// <param name="param0">Parameter 0 for string: The Type '{0}' must have a parameterless constructor.</param>
        internal static string NonAttributedSerializableTypesMustHaveDefaultConstructor(object param0) {
            return string.Format(Culture, ResourceManager.GetString("NonAttributedSerializableTypesMustHaveDefaultConstructor", Culture), param0);
        }
        
        /// <summary>Gets localized string like: {0} is a built-in type and cannot be a collection.</summary>
        /// <param name="param0">Parameter 0 for string: {0} is a built-in type and cannot be a collection.</param>
        internal static string CollectionTypeCannotBeBuiltIn(object param0) {
            return string.Format(Culture, ResourceManager.GetString("CollectionTypeCannotBeBuiltIn", Culture), param0);
        }
        
        /// <summary>Gets localized string like: {0} has DataContractAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: {0} has DataContractAttribute attribute.</param>
        internal static string CollectionTypeCannotHaveDataContract(object param0) {
            return string.Format(Culture, ResourceManager.GetString("CollectionTypeCannotHaveDataContract", Culture), param0);
        }
        
        /// <summary>Gets localized string like: {0} does not implement IEnumerable interface.</summary>
        /// <param name="param0">Parameter 0 for string: {0} does not implement IEnumerable interface.</param>
        internal static string CollectionTypeIsNotIEnumerable(object param0) {
            return string.Format(Culture, ResourceManager.GetString("CollectionTypeIsNotIEnumerable", Culture), param0);
        }
        
        /// <summary>Gets localized string like: {0} does not have a default constructor.</summary>
        /// <param name="param0">Parameter 0 for string: {0} does not have a default constructor.</param>
        internal static string CollectionTypeDoesNotHaveDefaultCtor(object param0) {
            return string.Format(Culture, ResourceManager.GetString("CollectionTypeDoesNotHaveDefaultCtor", Culture), param0);
        }
        
        /// <summary>Gets localized string like: {0} does not have a valid Add method with parameter of type '{1}'.</summary>
        /// <param name="param0">Parameter 0 for string: {0} does not have a valid Add method with parameter of type '{1}'.</param>
        /// <param name="param1">Parameter 1 for string: {0} does not have a valid Add method with parameter of type '{1}'.</param>
        internal static string CollectionTypeDoesNotHaveAddMethod(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("CollectionTypeDoesNotHaveAddMethod", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: {0} has multiple definitions of interface '{1}'.</summary>
        /// <param name="param0">Parameter 0 for string: {0} has multiple definitions of interface '{1}'.</param>
        /// <param name="param1">Parameter 1 for string: {0} has multiple definitions of interface '{1}'.</param>
        internal static string CollectionTypeHasMultipleDefinitionsOfInterface(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("CollectionTypeHasMultipleDefinitionsOfInterface", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' with CollectionDataContractAttribute attribute is an invalid collection type since it</param>
        internal static string InvalidCollectionDataContract(object param0) {
            return string.Format(Culture, ResourceManager.GetString("InvalidCollectionDataContract", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' is an invalid collection type since it</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' is an invalid collection type since it</param>
        internal static string InvalidCollectionType(object param0) {
            return string.Format(Culture, ResourceManager.GetString("InvalidCollectionType", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Collection type '{0}' cannot be deserialized since it</summary>
        /// <param name="param0">Parameter 0 for string: Collection type '{0}' cannot be deserialized since it</param>
        internal static string ReadOnlyCollectionDeserialization(object param0) {
            return string.Format(Culture, ResourceManager.GetString("ReadOnlyCollectionDeserialization", Culture), param0);
        }
        
        /// <summary>Gets localized string like: The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</summary>
        /// <param name="param0">Parameter 0 for string: The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</param>
        /// <param name="param1">Parameter 1 for string: The collection data contract type '{0}' specifies '{1}' for the KeyName property. This is not allowed since the type is not IDictionary. Remove the setting for the KeyName property.</param>
        internal static string InvalidCollectionContractKeyNoDictionary(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("InvalidCollectionContractKeyNoDictionary", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</summary>
        /// <param name="param0">Parameter 0 for string: The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</param>
        /// <param name="param1">Parameter 1 for string: The collection data contract type '{0}' specifies '{1}' for the ValueName property. This is not allowed since the type is not IDictionary. Remove the setting for the ValueName property.</param>
        internal static string InvalidCollectionContractValueNoDictionary(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("InvalidCollectionContractValueNoDictionary", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Collection type '{0}' does not have a valid GetEnumerator method.</summary>
        /// <param name="param0">Parameter 0 for string: Collection type '{0}' does not have a valid GetEnumerator method.</param>
        internal static string CollectionMustHaveGetEnumeratorMethod(object param0) {
            return string.Format(Culture, ResourceManager.GetString("CollectionMustHaveGetEnumeratorMethod", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Collection type '{0}' must have a non-null item type.</summary>
        /// <param name="param0">Parameter 0 for string: Collection type '{0}' must have a non-null item type.</param>
        internal static string CollectionMustHaveItemType(object param0) {
            return string.Format(Culture, ResourceManager.GetString("CollectionMustHaveItemType", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Collection type '{0}' does not have a valid Add method.</summary>
        /// <param name="param0">Parameter 0 for string: Collection type '{0}' does not have a valid Add method.</param>
        internal static string CollectionMustHaveAddMethod(object param0) {
            return string.Format(Culture, ResourceManager.GetString("CollectionMustHaveAddMethod", Culture), param0);
        }
        
        /// <summary>Gets localized string like: The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</summary>
        /// <param name="param0">Parameter 0 for string: The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</param>
        /// <param name="param1">Parameter 1 for string: The collection data contract type '{0}' specifies the same value '{1}' for both the KeyName and the ValueName properties. This is not allowed. Consider changing either the KeyName or the ValueName property.</param>
        internal static string DupKeyValueName(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("DupKeyValueName", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: The use of type '{0}' as a get-only collection is not supported with NetDataContractSerializer.  Consider marking the type with the CollectionDataContractAttribute attribute or the SerializableAttribute attribute or adding a setter to the property.</summary>
        /// <param name="param0">Parameter 0 for string: The use of type '{0}' as a get-only collection is not supported with NetDataContractSerializer.  Consider marking the type with the CollectionDataContractAttribute attribute or the SerializableAttribute attribute or adding a setter to the property.</param>
        internal static string ClassDataContractReturnedForGetOnlyCollection(object param0) {
            return string.Format(Culture, ResourceManager.GetString("ClassDataContractReturnedForGetOnlyCollection", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' is a recursive collection data contract which is not supported. Consider modifying the definition of collection '{0}' to remove references to itself.</param>
        internal static string RecursiveCollectionType(object param0) {
            return string.Format(Culture, ResourceManager.GetString("RecursiveCollectionType", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' has more than one CollectionDataContractAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' has more than one CollectionDataContractAttribute attribute.</param>
        internal static string TooManyCollectionContracts(object param0) {
            return string.Format(Culture, ResourceManager.GetString("TooManyCollectionContracts", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' has more than one DataContractAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' has more than one DataContractAttribute attribute.</param>
        internal static string TooManyDataContracts(object param0) {
            return string.Format(Culture, ResourceManager.GetString("TooManyDataContracts", Culture), param0);
        }
        
        /// <summary>Gets localized string like: DataContract namespace '{0}' is not a valid URI.</summary>
        /// <param name="param0">Parameter 0 for string: DataContract namespace '{0}' is not a valid URI.</param>
        internal static string DataContractNamespaceIsNotValid(object param0) {
            return string.Format(Culture, ResourceManager.GetString("DataContractNamespaceIsNotValid", Culture), param0);
        }
        
        /// <summary>Gets localized string like: DataContract namespace '{0}' cannot be specified since it is reserved.</summary>
        /// <param name="param0">Parameter 0 for string: DataContract namespace '{0}' cannot be specified since it is reserved.</param>
        internal static string DataContractNamespaceReserved(object param0) {
            return string.Format(Culture, ResourceManager.GetString("DataContractNamespaceReserved", Culture), param0);
        }
        
        /// <summary>Gets localized string like: CLR namespace '{0}' cannot have ContractNamespace set to null.</summary>
        /// <param name="param0">Parameter 0 for string: CLR namespace '{0}' cannot have ContractNamespace set to null.</param>
        internal static string InvalidGlobalDataContractNamespace(object param0) {
            return string.Format(Culture, ResourceManager.GetString("InvalidGlobalDataContractNamespace", Culture), param0);
        }
        
        /// <summary>Gets localized string like: ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</summary>
        /// <param name="param0">Parameter 0 for string: ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</param>
        /// <param name="param1">Parameter 1 for string: ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</param>
        /// <param name="param2">Parameter 2 for string: ContractNamespaceAttribute attribute maps CLR namespace '{2}' to multiple data contract namespaces '{0}' and '{1}'. You can map a CLR namespace to only one data contract namespace.</param>
        internal static string DataContractNamespaceAlreadySet(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("DataContractNamespaceAlreadySet", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: The data contract name '{0}' for type '{1}' has a curly brace that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</summary>
        /// <param name="param0">Parameter 0 for string: The data contract name '{0}' for type '{1}' has a curly brace that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</param>
        /// <param name="param1">Parameter 1 for string: The data contract name '{0}' for type '{1}' has a curly brace that is not matched with a closing curly brace. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types.</param>
        internal static string GenericNameBraceMismatch(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("GenericNameBraceMismatch", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot be serialized. Consider marking it with the DataContractAttribute attribute, and marking all of its members you want serialized with the DataMemberAttribute attribute.  If the type is a collection, consider marking it with the CollectionDataContractAttribute.  See the Microsoft .NET Framework documentation for other supported types.</param>
        internal static string TypeNotSerializable(object param0) {
            return string.Format(Culture, ResourceManager.GetString("TypeNotSerializable", Culture), param0);
        }
        
        /// <summary>Gets localized string like: In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</summary>
        /// <param name="param0">Parameter 0 for string: In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</param>
        /// <param name="param1">Parameter 1 for string: In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</param>
        /// <param name="param2">Parameter 2 for string: In the data contract name for type '{1}', there are curly braces with '{0}' inside, which is an invalid value. Curly braces have special meaning in data contract names - they are used to customize the naming of data contracts for generic types. Based on the number of generic parameters this type has, the contents of the curly braces must either be a number between 0 and '{2}' to insert the name of the generic parameter at that index or the '#' symbol to insert a digest of the generic parameter namespaces.</param>
        internal static string GenericParameterNotValid(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("GenericParameterNotValid", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</summary>
        /// <param name="param0">Parameter 0 for string: Method name specified by KnownTypeAttribute attribute on type '{0}' cannot be the empty string.</param>
        internal static string KnownTypeAttributeEmptyString(object param0) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeAttributeEmptyString", Culture), param0);
        }
        
        /// <summary>Gets localized string like: KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</summary>
        /// <param name="param0">Parameter 0 for string: KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</param>
        /// <param name="param1">Parameter 1 for string: KnownTypeAttribute attribute on type '{1}' specifies a method named '{0}' to provide known types. Static method '{0}()' was not found on this type. Ensure that the method exists and is marked as static.</param>
        internal static string KnownTypeAttributeUnknownMethod(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeAttributeUnknownMethod", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable<Type>. Ensure that the method exists and has a valid signature.</summary>
        /// <param name="param0">Parameter 0 for string: KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable<Type>. Ensure that the method exists and has a valid signature.</param>
        /// <param name="param1">Parameter 1 for string: KnownTypeAttribute attribute on type '{0}' specifies a method named '{1}' to provide known types. The return type of this method is invalid because it is not assignable to IEnumerable<Type>. Ensure that the method exists and has a valid signature.</param>
        internal static string KnownTypeAttributeReturnType (object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeAttributeReturnType ", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}': If a KnownTypeAttribute attribute specifies a method it must be the only KnownTypeAttribute attribute on that type.</param>
        internal static string KnownTypeAttributeOneScheme(object param0) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeAttributeOneScheme", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</summary>
        /// <param name="param0">Parameter 0 for string: Method specified by KnownTypeAttribute attribute on type '{0}' does not expose valid types.</param>
        internal static string KnownTypeAttributeValidMethodTypes(object param0) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeAttributeValidMethodTypes", Culture), param0);
        }
        
        /// <summary>Gets localized string like: KnownTypeAttribute attribute on type '{0}' contains no data.</summary>
        /// <param name="param0">Parameter 0 for string: KnownTypeAttribute attribute on type '{0}' contains no data.</param>
        internal static string KnownTypeAttributeNoData(object param0) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeAttributeNoData", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</summary>
        /// <param name="param0">Parameter 0 for string: Method specified by KnownTypeAttribute attribute on type '{0}' returned null.</param>
        internal static string KnownTypeAttributeMethodNull (object param0) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeAttributeMethodNull ", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Error while getting known types for Type '{0}'. The type must not be an open or partial generic class.</summary>
        /// <param name="param0">Parameter 0 for string: Error while getting known types for Type '{0}'. The type must not be an open or partial generic class.</param>
        internal static string TypeMustBeConcrete(object param0) {
            return string.Format(Culture, ResourceManager.GetString("TypeMustBeConcrete", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Declared type '{0}' in config cannot be a closed or partial generic type.</summary>
        /// <param name="param0">Parameter 0 for string: Declared type '{0}' in config cannot be a closed or partial generic type.</param>
        internal static string KnownTypeConfigClosedGenericDeclared(object param0) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeConfigClosedGenericDeclared", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List<Test> and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List<Test> and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</param>
        /// <param name="param1">Parameter 1 for string: Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List<Test> and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</param>
        /// <param name="param2">Parameter 2 for string: Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List<Test> and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</param>
        /// <param name="param3">Parameter 3 for string: Type '{0}' cannot be added to list of known types since another type '{1}' with the same data contract name '{2}:{3}' is already present. If there are different collections of a particular type - for example, List<Test> and Test[], they cannot both be added as known types.  Consider specifying only one of these types for addition to the known types list.</param>
        internal static string DupContractInKnownTypes(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("DupContractInKnownTypes", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: Type '{0}' is not a fully instantiated generic class.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' is not a fully instantiated generic class.</param>
        internal static string TypeMustNotBeOpenGeneric(object param0) {
            return string.Format(Culture, ResourceManager.GetString("TypeMustNotBeOpenGeneric", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot be exported as a schema type because it is an open generic type. You can only export a generic type if all its generic parameter types are actual types.</param>
        internal static string GenericTypeNotExportable(object param0) {
            return string.Format(Culture, ResourceManager.GetString("GenericTypeNotExportable", Culture), param0);
        }
        
        /// <summary>Gets localized string like: DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</summary>
        /// <param name="param0">Parameter 0 for string: DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</param>
        /// <param name="param1">Parameter 1 for string: DataContract with name '{0}' and namespace '{1}' cannot be added to DataContractSet since another contract with the same data contract name is already present and the contracts are not equivalent.</param>
        internal static string DupContractInDataContractSet(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("DupContractInDataContractSet", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</summary>
        /// <param name="param0">Parameter 0 for string: DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</param>
        /// <param name="param1">Parameter 1 for string: DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</param>
        /// <param name="param2">Parameter 2 for string: DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</param>
        /// <param name="param3">Parameter 3 for string: DataContract for type '{0}' cannot be added to DataContractSet since type '{1}' with the same data contract name '{2}' in namespace '{3}' is already present and the contracts are not equivalent.</param>
        internal static string DupTypeContractInDataContractSet(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("DupTypeContractInDataContractSet", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'.</summary>
        /// <param name="param0">Parameter 0 for string: Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'.</param>
        /// <param name="param1">Parameter 1 for string: Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'.</param>
        /// <param name="param2">Parameter 2 for string: Using surrogates with get-only collection properties is not supported.  Consider removing the surrogate associated with '{0}' or adding a setter to '{1}.{2}'.</param>
        internal static string SurrogatesWithGetOnlyCollectionsNotSupported(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("SurrogatesWithGetOnlyCollectionsNotSupported", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</summary>
        /// <param name="param0">Parameter 0 for string: List of referenced types contains more than one type with same data contract name. Need to exclude all but one of the following types. Only matching types can be valid references: {0}</param>
        internal static string AmbiguousReferencedTypes1(object param0) {
            return string.Format(Culture, ResourceManager.GetString("AmbiguousReferencedTypes1", Culture), param0);
        }
        
        /// <summary>Gets localized string like: List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</summary>
        /// <param name="param0">Parameter 0 for string: List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</param>
        /// <param name="param1">Parameter 1 for string: List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</param>
        /// <param name="param2">Parameter 2 for string: List of referenced types contains more than one type with data contract name '{0}' in namespace '{1}'. Need to exclude all but one of the following types. Only matching types can be valid references: {2}</param>
        internal static string AmbiguousReferencedTypes3(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("AmbiguousReferencedTypes3", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</summary>
        /// <param name="param0">Parameter 0 for string: List of referenced collection types contains more than one type with same data contract name. Include only one of the following types. Only matching types can be valid references: {0}</param>
        internal static string AmbiguousReferencedCollectionTypes1(object param0) {
            return string.Format(Culture, ResourceManager.GetString("AmbiguousReferencedCollectionTypes1", Culture), param0);
        }
        
        /// <summary>Gets localized string like: List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</summary>
        /// <param name="param0">Parameter 0 for string: List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</param>
        /// <param name="param1">Parameter 1 for string: List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</param>
        /// <param name="param2">Parameter 2 for string: List of referenced collection types contains more than one type with data contract name '{0}' in namespace '{1}'. Include only one of the following types. Only matching types can be valid references: {2}</param>
        internal static string AmbiguousReferencedCollectionTypes3(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("AmbiguousReferencedCollectionTypes3", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: The value '{0}' cannot be parsed as the type '{1}'.</summary>
        /// <param name="param0">Parameter 0 for string: The value '{0}' cannot be parsed as the type '{1}'.</param>
        /// <param name="param1">Parameter 1 for string: The value '{0}' cannot be parsed as the type '{1}'.</param>
        internal static string XmlInvalidConversion(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("XmlInvalidConversion", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</summary>
        /// <param name="param0">Parameter 0 for string: Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</param>
        /// <param name="param1">Parameter 1 for string: Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</param>
        /// <param name="param2">Parameter 2 for string: Enum type '{0}' cannot have the IsReference setting of '{1}'. Either change the setting to '{2}', or remove it completely.</param>
        internal static string EnumTypeCannotHaveIsReference(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("EnumTypeCannotHaveIsReference", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</param>
        /// <param name="param1">Parameter 1 for string: Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</param>
        /// <param name="param2">Parameter 2 for string: Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</param>
        /// <param name="param3">Parameter 3 for string: Type '{0}' in namespace '{1}' is not a valid base type for enum '{2}' in namespace '{3}'.</param>
        internal static string InvalidEnumBaseType(object param0, object param1, object param2, object param3) {
            return string.Format(Culture, ResourceManager.GetString("InvalidEnumBaseType", Culture), param0, param1, param2, param3);
        }
        
        /// <summary>Gets localized string like: Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</param>
        /// <param name="param1">Parameter 1 for string: Member '{0}.{1}' has more than one EnumMemberAttribute attribute.</param>
        internal static string TooManyEnumMembers(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("TooManyEnumMembers", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead.</summary>
        /// <param name="param0">Parameter 0 for string: Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead.</param>
        /// <param name="param1">Parameter 1 for string: Member '{0}.{1}' has DataMemberAttribute attribute. Use EnumMemberAttribute attribute instead.</param>
        internal static string DataMemberOnEnumField(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("DataMemberOnEnumField", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: XML data contract Name for type '{0}' cannot be set to null or empty string.</summary>
        /// <param name="param0">Parameter 0 for string: XML data contract Name for type '{0}' cannot be set to null or empty string.</param>
        internal static string InvalidXmlDataContractName(object param0) {
            return string.Format(Culture, ResourceManager.GetString("InvalidXmlDataContractName", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot have MethodName on XmlSchemaProviderAttribute attribute set to null or empty string.</param>
        internal static string InvalidGetSchemaMethod(object param0) {
            return string.Format(Culture, ResourceManager.GetString("InvalidGetSchemaMethod", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</param>
        /// <param name="param1">Parameter 1 for string: Type '{0}' does not have a static method '{1}' that takes a parameter of type 'System.Xml.Schema.XmlSchemaSet' as specified by the XmlSchemaProviderAttribute attribute.</param>
        internal static string MissingGetSchemaMethod(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("MissingGetSchemaMethod", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</summary>
        /// <param name="param0">Parameter 0 for string: Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</param>
        /// <param name="param1">Parameter 1 for string: Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</param>
        /// <param name="param2">Parameter 2 for string: Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</param>
        /// <param name="param3">Parameter 3 for string: Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</param>
        /// <param name="param4">Parameter 4 for string: Method '{0}.{1}()' returns '{2}'. The return type must be compatible with '{3}' or '{4}'.</param>
        internal static string InvalidReturnTypeOnGetSchemaMethod(object param0, object param1, object param2, object param3, object param4) {
            return string.Format(Culture, ResourceManager.GetString("InvalidReturnTypeOnGetSchemaMethod", Culture), param0, param1, param2, param3, param4);
        }
        
        /// <summary>Gets localized string like: Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</summary>
        /// <param name="param0">Parameter 0 for string: Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</param>
        /// <param name="param1">Parameter 1 for string: Method '{0}.{1}()' returns a non-null value. The return value must be null since IsAny=true.</param>
        internal static string InvalidNonNullReturnValueByIsAny(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("InvalidNonNullReturnValueByIsAny", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Schema type '{0}' returned by CLR type '{1}' is not found in the XmlSchemaSet.</summary>
        /// <param name="param0">Parameter 0 for string: Schema type '{0}' returned by CLR type '{1}' is not found in the XmlSchemaSet.</param>
        /// <param name="param1">Parameter 1 for string: Schema type '{0}' returned by CLR type '{1}' is not found in the XmlSchemaSet.</param>
        internal static string MissingSchemaType(object param0, object param1) {
            return string.Format(Culture, ResourceManager.GetString("MissingSchemaType", Culture), param0, param1);
        }
        
        /// <summary>Gets localized string like: Method '{0}.GetSchema()' must return a schema with a valid Id.</summary>
        /// <param name="param0">Parameter 0 for string: Method '{0}.GetSchema()' must return a schema with a valid Id.</param>
        internal static string InvalidReturnSchemaOnGetSchemaMethod(object param0) {
            return string.Format(Culture, ResourceManager.GetString("InvalidReturnSchemaOnGetSchemaMethod", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot be IXmlSerializable and have CollectionDataContractAttribute attribute.</param>
        internal static string IXmlSerializableCannotHaveCollectionDataContract(object param0) {
            return string.Format(Culture, ResourceManager.GetString("IXmlSerializableCannotHaveCollectionDataContract", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot be IXmlSerializable and have DataContractAttribute attribute.</param>
        internal static string IXmlSerializableCannotHaveDataContract(object param0) {
            return string.Format(Culture, ResourceManager.GetString("IXmlSerializableCannotHaveDataContract", Culture), param0);
        }
        
        /// <summary>Gets localized string like: Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</summary>
        /// <param name="param0">Parameter 0 for string: Type '{0}' cannot specify an XmlRootAttribute attribute because its IsAny setting is 'true'. This type must write all its contents including the root element. Verify that the IXmlSerializable implementation is correct.</param>
        internal static string IsAnyCannotHaveXmlRoot(object param0) {
            return string.Format(Culture, ResourceManager.GetString("IsAnyCannotHaveXmlRoot", Culture), param0);
        }
        
        /// <summary>Gets localized string like: The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed.</summary>
        /// <param name="param0">Parameter 0 for string: The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed.</param>
        /// <param name="param1">Parameter 1 for string: The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed.</param>
        /// <param name="param2">Parameter 2 for string: The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed.</param>
        internal static string KnownTypeConfigIndexOutOfBoundsZero(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeConfigIndexOutOfBoundsZero", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed. Parameter index must be greater than or equal to 0 and less than '{1}'.</summary>
        /// <param name="param0">Parameter 0 for string: The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed. Parameter index must be greater than or equal to 0 and less than '{1}'.</param>
        /// <param name="param1">Parameter 1 for string: The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed. Parameter index must be greater than or equal to 0 and less than '{1}'.</param>
        /// <param name="param2">Parameter 2 for string: The type '{0}' in config has '{1}' generic parameters(s). Parameter '{2}' cannot be accessed. Parameter index must be greater than or equal to 0 and less than '{1}'.</param>
        internal static string KnownTypeConfigIndexOutOfBounds(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeConfigIndexOutOfBounds", Culture), param0, param1, param2);
        }
        
        /// <summary>Gets localized string like: The type '{0}' in config has '{1}' generic parameter(s) but '{2}' generic argument(s) were provided. The number of generic arguments must match the number of generic parameters.</summary>
        /// <param name="param0">Parameter 0 for string: The type '{0}' in config has '{1}' generic parameter(s) but '{2}' generic argument(s) were provided. The number of generic arguments must match the number of generic parameters.</param>
        /// <param name="param1">Parameter 1 for string: The type '{0}' in config has '{1}' generic parameter(s) but '{2}' generic argument(s) were provided. The number of generic arguments must match the number of generic parameters.</param>
        /// <param name="param2">Parameter 2 for string: The type '{0}' in config has '{1}' generic parameter(s) but '{2}' generic argument(s) were provided. The number of generic arguments must match the number of generic parameters.</param>
        internal static string KnownTypeConfigGenericParamMismatch(object param0, object param1, object param2) {
            return string.Format(Culture, ResourceManager.GetString("KnownTypeConfigGenericParamMismatch", Culture), param0, param1, param2);
        }
    }
}

